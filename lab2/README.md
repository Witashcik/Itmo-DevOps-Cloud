# Лабораторная работа 2

## Dockerfile с использованием Bad Practices

```
# Использование слишком тяжёлых базовых образов
FROM ubuntu:latest

# Установка зависимостей без очистки кэша
RUN apt-get update && apt-get install -y python3

# Отсутствие указания конкретных версий пакетов
RUN pip install flask
```

* Само по себе использование тяжёлых образов, таких как ubuntu:latest нецелесообразно, так как это приводит к увелечению размера образа и времени его сборки. Поэтому лучше использовать легковесные образы, например python:3.9-alpine, так как они содержат минимально необходимый набор пакетов.

* Когда мы устанавливаем пакеты, при этом не очищая кэш, то все временные файлы остаются в образе, что ведёт к увеличению его размера. Поэтому после установки пакетов мы должны чистить кэш и временные файлы.

* При установке пакетов без указания версии, сборка становится опасной. Каждая последующая сборка может начать работать с пакетами разных версий при обновлении, что может повлечь за собой баги, проблемы с совместимостью и краши. Именно поэтому нужно указывать конкретные версии при установке пакетов.

## Dockerfile с использованием Best Practices

```
# Использование легковесных образов
FROM Python:3.9-alpine

# Очистка кэша после установки пакетов
RUN apt-get update && apt-get install -y python3 && rm -rf /var/lib/apt/lists*

# Указание конкретных версий пакетов
RUN pip install flask==2.0.1
```

## Bed Practices (Dockerfile) в работе с контейнерами

* Запуск контейнера с правами суперпользователя (root):

  Зачастую контейнеры запускаются от имени суперпользователя. С одной стороны это может показаться удобным, но на деле 
  это большой риск для безопасности, так как если некто получит доступ к контейнеру, то он будет обладать правами 
  суперпользователя.
  Именно поэтому стоит создавать специально выделенных пользователей с минимальными правами внутри контейнера.

* Неправильное управление данными:

  Зачастую контейнеры запускаются с данными, которые хранятся только в самом контейнере. Однако если контейнер по какой- 
  либо причине будет удалён, то все данные в неё будут безвозвратно утеряны.
  Решение простое - необходимо использовать тома для хранения данных вне используемого контейнера. В этом случае данные 
  будут сохранятся на хосте и если вдруг контейнер будет удалён, то данные будут сохранены
  

# Лабораторная работа 2 `*`

## docker-compose с использованием Bad Practices

```
version: "4"

services: 
  someDB:
    image: someBD:latest
    container_name: amazing.App_db
    environment: #ну это плохо явно
      NAME_DB: "amazing.App_db"
      USER: "skufyari"
      PASSWORD: "S3cR3t14/88"
    volumes:
      - .:/ #неявный путь
    ports:
      - "80:80" #явный порт

  app: 
    build: 
      context: ./ #неявный путь
      dockerfile: Dockerfile 
    command: > #команда которую нужно выполнить
      /bin/sh -c 'some useful command'
```

* Хранение секретов в коде

  Переменные окружения для базы данных, такие как имя пользователя и пароль, указаны напрямую в файле. Это плохо для безопасности, так как чувствительные данные могут случайно попасть в репозиторий и быть раскрыты
* Неявные пути
  
  В volumes монтируется текущая директория `./` на корневой уровень контейнера `/`. Это может вызвать проблемы, так как не указано, какие именно файлы должны быть смонтированы. Такое монтирование может перекрыть важные файлы в контейнере

* Явный порт

  Использование стандартного порта `80:80` может привести к конфликтам, если на машине уже запущен другой сервис на порту 80

## Docker-compose с использованием Best Practices

```
version: "4"

services: 
  someDB:
    image: someBD:latest
    container_name: amazing.App_db
    env_file: #а это круто
      - .env.db 
    volumes:
      - .:/DB_data:/var/lib/name_DB/data
    ports:
      - "8080:80"
    restart: always #перезагрузка при ошибке

  app: #сам контейнер (его имя)
    build: # создание контейнера???
      context: ./
      dockerfile: Dockerfile 
  depends_on:
      - someDB
  volumes:
      - .:/app
  command: > # команда которую нужно выполнить
      /bin/sh 'some useful command'

volumes:
  DB_data:
```

## Bed Practices (Docker-compose) в работе с контейнерами

* Хранение секретов в файле

  Вместо того, чтобы прописывать данные для входа в базу данных прямо в файле, используется внешняя переменная окружения из файла .env.db. Это значительно повышает безопасность конфигурации

* Явные и четкие пути

  Монтирование данных для базы данных `DB_data` указывает явный путь, что позволяет избежать ошибок с заменой системных файлов контейнера. Это более понятно и так проще работать с контейнером

* Использование нестандартного порта

  Порт `8080` для внешнего подключения вместо 80 снижает вероятность конфликтов с другими сервисами, запущенными на хосте

* Автоматическая перезагрузка

  Добавлен параметр `restart: always`, что позволяет базе данных перезапускаться в случае сбоя. Это повышает надежность приложения

* Зависимость между сервисами

  Использование `depends_on` гарантирует, что приложение запустится только после того, как база данных будет готова, что предотвращает ошибки при запуске
