# Лабораторная работа 2

## Dockerfile с использованием Bad Practices

```
# Использование слишком тяжёлых базовых образов
FROM ubuntu:latest

# Установка зависимостей без очистки кэша
RUN apt-get update && apt-get install -y python3

# Отсутствие указания конкретных версий пакетов
RUN pip install flask
```

* Само по себе использование тяжёлых образов, таких как ubuntu:latest нецелесообразно, так как это приводит к увелечению размера образа и времени его сборки. Поэтому лучше использовать легковесные образы, например python:3.9-alpine, так как они содержат минимально необходимый набор пакетов.

* Когда мы устанавливаем пакеты, при этом не очищая кэш, то все временные файлы остаются в образе, что ведёт к увеличению его размера. Поэтому после установки пакетов мы должны чистить кэш и временные файлы.

* При установке пакетов без указания версии, сборка становится опасной. Каждая последующая сборка может начать работать с пакетами разных версий при обновлении, что может повлечь за собой баги, проблемы с совместимостью и краши. Именно поэтому нужно указывать конкретные версии при установке пакетов.

## Dockerfile с использованием Best Practices

```
# Использование легковесных образов
FROM Python:3.9-alpine

# Очистка кэша после установки пакетов
RUN apt-get update && apt-get install -y python3 && rm -rf /var/lib/apt/lists*

# Указание конкретных версий пакетов
RUN pip install flask==2.0.1
```

## Bed Practices (Dockerfile) в работе с контейнерами

* Запуск контейнера с правами суперпользователя (root):

  Зачастую контейнеры запускаются от имени суперпользователя. С одной стороны это может показаться удобным, но на деле 
  это большой риск для безопасности, так как если некто получит доступ к контейнеру, то он будет обладать правами 
  суперпользователя.
  Именно поэтому стоит создавать специально выделенных пользователей с минимальными правами внутри контейнера.

* Неправильное управление данными:

  Зачастую контейнеры запускаются с данными, которые хранятся только в самом контейнере. Однако если контейнер по какой- 
  либо причине будет удалён, то все данные в неё будут безвозвратно утеряны.
  Решение простое - необходимо использовать тома для хранения данных вне используемого контейнера. В этом случае данные 
  будут сохранятся на хосте и если вдруг контейнер будет удалён, то данные будут сохранены
  

# Лабораторная работа 2 `*`

## docker-compose с использованием Bad Practices

```
version: "4"

services:
  web:
    image: python:3.9-alpine
    build:
      context: .
    ports:
      - "5000:5000"
    volumes:
      - ./app:/app  # Прямое монтирование кода из хоста в контейнер
    environment:
      FLASK_ENV: development  # Использование режима разработки в продакшене
    command: >
      sh -c "pip install flask==2.0.1 && python3 -m flask run --host=0.0.0.0 --port=5000"
```

* Монтирование исходного кода как volume:

  - Прямое подключение исходного кода через volumes приводит к отсутствию контроля версии внутри контейнера.
  - Возможны ошибки, связанные с несовместимыми зависимостями между хостом и контейнером.

* Установка зависимостей при запуске контейнера
  
  - Установка пакетов в команде запуска `command` приводит к увеличению времени старта контейнера и к отсутствию контроля версий в слое сборки.

* Отсутствие network-конфигурации

 - Контейнер работает в режиме bridge по умолчанию, что может вызвать конфликты с другими контейнерами.

## Docker-compose с использованием Best Practices

```
version: "4"

services:
  web:
    build:
      context: .
      dockerfile: Dockerfile
    ports:
      - "5000:5000"
    environment:
      FLASK_APP: app.py  # Четкое определение запускаемого приложения
    command: python3 -m flask run --host=0.0.0.0 --port=5000
    networks:
      - app_network

networks:
  app_network:
    driver: bridge
```

## Bed Practices (Docker-compose) в работе с контейнерами

* Сборка зависимостей на этапе сборки образа

  - Весь код и зависимости устанавливаются в Dockerfile. Это обеспечивает одинаковую среду на всех этапах работы приложения.

* Изоляция сети

  - Используется отдельная пользовательская сеть `app_network`, что обеспечивает лучшую изоляцию между контейнерами.

* Отказ от монтирования кода

 - Код копируется в образ на этапе сборки. Это гарантирует, что все тесты и сборка проходят в контролируемой среде.

* Указание конкретных переменных окружения

 - Вместо режима разработки задается только необходимая переменная `FLASK_APP`, исключая ненужные риски.
